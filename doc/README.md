# SERG: Shifting Euclidean Rhythm Generator

SERG is a music composition tool inspired by Steve Reichs concept of phase shifting rhythms.

## Introduction

### What are Phase Shifting Rhythms

Phase Shifting Rhythms is the name we have given to a technique that Steve Reich used across his discography.

To explain the concept we will take his piece “Clapping Music for Two Performers” as an example:
* The piece starts with both performers clapping a 1 bar rhythm in unison, repeated 12 times.
* On bar 13 the 1st player continues the rhythm as normal. However, the 2nd player claps a rhythm that is the original rhythm circular shifted by one pulse. Again this is repeated for 12 bars.
* This process of circular shifting is repeated until the 2nd player's rhythm has been shifted back to it's original position.

This simple principle is amazing at producing some very unique feeling rhythmic pieces as the two rhythms go in and out of phase. There is a push-pull effect felt as syncopation is intermittently introduced.
It is this concept of shifting a rhythm over time that our project is based on.

### What are Euclidean Rhythms

Euclidean Rhythm was discovered by Godfried Toussaint in 2004. It uses the Euclidean Algorithm to generate musical rhythms. What is most interesting is that the rhythms it produces and describes are traditional rhythms from all over the world, and rhythms that are found in modern electronic dance music. The greatest common divisor of two numbers is used to create the rhythm where the beats are as equidistant as possible.

The two numbers used to produce the rhythm are called onsets and pulses. Onsets the number of hits/beats in the bar. Pulses describes the number beats in the rhythm or the subdivision of the bar the rhythm is in.

For example 3 onsets, 8 pulses in our context creates a 1 bar rhythm of 1/8th notes with 3 hits in the bar. The resulting rhythm would be “10010010”. A 1 representing an onset and a 0 a silence.  When we look at world music we find this to be the Cuban Tresillo.

We chose to use Euclidean Rhythms for our base rhythms as they automatically sound “Good”. As Euclidean Rhythms are ones found throughout music both traditional and modern they contain some invariant quality that is highly agreeable to the listener.

### SERG's Design

SERG has two sets of phase shifting rhythms that are played in sync.

Set 1 consisting of Track 1 and Track 2, and Set 2 consisting of Track 3 and Track 4.

The base rhythm for each set is generated by a euclidean rhythm.

Blah blah blah

## Technical Description

### Technologies Used

### Project Structure

### Flowchart


### GUI
### GUI
The Graphic User Interface is generated using P5.js. Therefore, it was implemented a circular representation for the rhythms based on the flow of the time as we can see it in a clock, an easy way to understand and visulize Polyrhythms. In that way, the visualization was generated with some functions as described bellow:

#### Fixed_Circles(track):
This function receive as input the number of the Track, Track 1 or Track 3, and draws the main circle taking the binary array of each rhythm generated by the *euclideanPattern()* function. The first pulse is setup at 12 o'clock and the subdivisions go clockwise according to the number of pulses, as it is shown in the following figure, with 4 onsets and 8 pulses.
![FixedCircle()](https://github.com/hfoley03/musical-guacamole/blob/Design_2/img/FixedCircle.png?raw=?)

#### VisualFix(track):
This function has as inputs the track number, Track 1 or Track 3, to consider the pulses on the specific track to draw an arc to highlight the pulse of the main circle that is sounding clockwise direction. as it is shown in the following figure.
![VisualFixedCircle()](https://github.com/hfoley03/musical-guacamole/blob/Design_2/img/VisualFixedCircle.png?raw=?)

### Browser Play

Overview of BrowserPlay.js
Outline key and interesting functions

### Midi Generation

The generation of the midi object is handled by the javascript file midiGeneration. The process is divided  among several functions, with the function generateMidi handling the overall flow.

#### euclideanPattern(onsets, pulses)

The first step in building the MIDI object for the piece is to create the base Euclidean Rhythm. This is handled by the function euclideanPattern. The function has two input arguments, onsets and pulses. The function returns a string with a binary representation of the Euclidean Rhythm. For example with inputs onsets = 5 and pulses = 8, the function would return
```
“10110110”
```
With a 1 representing an onset and a 0 a pulse without an onset.
The generation of Euclidean Rhythm was designed from the description in Godfried T. Toussaint’s book The Geometry of Musical Rhythm, chapter 19 “Euclidean Rhythms”.
The algorithm was designed from scratch using the method he described. The figure below is taken from The Geometry of Musical Rhythm and shows a visual representation of the algorithm with 5 onsets and 8 pulses.

#### binaryRhythmToMidi(binaryRhythm, midiObject, pulseInTicks, offset)

This function is responsible for transforming the binary string representation of a Euclidean Rhythm into a Tone.js MIDI object. It’s input arguments are binaryRhythm (the binary string of the Euclidean rhythm), midiObject (an empty Tone.js midi object), pulseInTicks (the number of ticks in one pulse) and offset (used to decide if the function is creating tracks 1 & 2 or tracks 3 & 4). It returns a midi object with one bar of Euclidean rhythm in each of the four tracks.

#### createNote(track_, timeTicks, pulseInTicks_)

Adds a midi note to a tracks at a specific time in ticks. The octave of the note depends on the track number. Input arguments are track_ (the track that the note should be added to), timeTicks (when the note should happen in ticks) and pulseInTicks_ (the duration of a pulse in ticks, used to set the length of the note)

#### pitch()

This function is called by createNote to specify what the note letter value will be.
If the user is working in C major with no colour notes selected the function will always return “C”.
If the user has selected colour notes 3 and 5, and with a colour amount of 30%, the function will have a 70% chance of returning “C” and a 30% chance of returning an “E” or “G” (the 3rd and 5th degree of the C Major Scale). These values will change as expected for example if the user specifies D Minor with colour notes 2,4,7.

#### vel()

This function returns a random velocity value for a midi note. The range that this velocity value can be is controlled by the user. If the user has the range at its minium size the function always returns 1.0, max velocity. If the user has the range at 1/4 the values returned will be between 0.75 – 1.0. At maximum range the values returned will be between 0.1 – 1.0.

#### calcScale(key, intervals)

This function creates a scale given a root note and intervals array. The intervals array describes the pattern of intervals in a scale. For example a major scale is represented by
```
let major = [2,2,1,2,2,2,1]
```
#### userSelectedNotes(userSelected, scaleCalculated)

This function reduces the scale created in calcScale to just the notes that the user desires. For example if the user wants C Major with colour notes 4 & 5, the function returns
```
[“C”, “F”, “G”]
```

#### phaseAndCompose(midiInProgress,phaseShiftAmount, phaseShiftPeriod,length)

This function is responsible for creating the MIDI object containing the full composition of all 4 tracks that will be played back in the browser.

Its input arguments are midiInProgress (a MIDI object with four tracks, with each track containing a one bar Euclidean Rhythm), phaseShiftAmount (by how many pulses should a rhythm be shifted by), phaseShiftPeriod(after how many bars should a shift occur) and length (the overall length of the composition in bars).
The function returns the final MIDI object.

The flow chart in fig. x shows a high level flow of this function.

![Image of phaseAndCompose() flowchart](https://github.com/hfoley03/musical-guacamole/blob/Design_2/img/phaseAndComposeDiagram.png?raw=true)


## Challenges

### Challenge 1

give description of challenge, solutions tried and final solution

## Future Work

Things we would like to improve on or change



